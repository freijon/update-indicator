/* Indicate.c generated by valac 0.14.0, the Vala compiler
 * generated from Indicate.vala, do not modify */

/*  */
/*  Indicate.vala*/
/*  */
/*  Author:*/
/*       Jonas Frei <freijon@gmail.com>*/
/* */
/*  Copyright (c) 2011 Jonas Frei*/
/* */
/*  This program is free software: you can redistribute it and/or modify*/
/*  it under the terms of the GNU General Public License as published by*/
/*  the Free Software Foundation, either version 3 of the License, or*/
/*  (at your option) any later version.*/
/* */
/*  This program is distributed in the hope that it will be useful,*/
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of*/
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the*/
/*  GNU General Public License for more details.*/
/* */
/*  You should have received a copy of the GNU General Public License*/
/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.*/

#include <glib.h>
#include <glib-object.h>
#include <libappindicator/app-indicator.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <libnotify/notify.h>
#include <cairo.h>
#include <float.h>
#include <math.h>
#include <gobject/gvaluecollector.h>


#define TYPE_INDICATE (indicate_get_type ())
#define INDICATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_INDICATE, Indicate))
#define INDICATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_INDICATE, IndicateClass))
#define IS_INDICATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_INDICATE))
#define IS_INDICATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_INDICATE))
#define INDICATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_INDICATE, IndicateClass))

typedef struct _Indicate Indicate;
typedef struct _IndicateClass IndicateClass;
typedef struct _IndicatePrivate IndicatePrivate;

#define TYPE_UPDATE_CHECKER (update_checker_get_type ())
#define UPDATE_CHECKER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_UPDATE_CHECKER, UpdateChecker))
#define UPDATE_CHECKER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_UPDATE_CHECKER, UpdateCheckerClass))
#define IS_UPDATE_CHECKER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_UPDATE_CHECKER))
#define IS_UPDATE_CHECKER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_UPDATE_CHECKER))
#define UPDATE_CHECKER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_UPDATE_CHECKER, UpdateCheckerClass))

typedef struct _UpdateChecker UpdateChecker;
typedef struct _UpdateCheckerClass UpdateCheckerClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _update_checker_unref0(var) ((var == NULL) ? NULL : (var = (update_checker_unref (var), NULL)))

#define GCONF_INTERFACE_TYPE_KEY (gconf_interface_key_get_type ())
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _cairo_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_destroy (var), NULL)))
#define _cairo_surface_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_surface_destroy (var), NULL)))

#define TYPE_PREFERENCES_DIALOG (preferences_dialog_get_type ())
#define PREFERENCES_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PREFERENCES_DIALOG, PreferencesDialog))
#define PREFERENCES_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PREFERENCES_DIALOG, PreferencesDialogClass))
#define IS_PREFERENCES_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PREFERENCES_DIALOG))
#define IS_PREFERENCES_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PREFERENCES_DIALOG))
#define PREFERENCES_DIALOG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PREFERENCES_DIALOG, PreferencesDialogClass))

typedef struct _PreferencesDialog PreferencesDialog;
typedef struct _PreferencesDialogClass PreferencesDialogClass;
#define _preferences_dialog_unref0(var) ((var == NULL) ? NULL : (var = (preferences_dialog_unref (var), NULL)))
typedef struct _ParamSpecIndicate ParamSpecIndicate;

struct _Indicate {
	GTypeInstance parent_instance;
	volatile int ref_count;
	IndicatePrivate * priv;
};

struct _IndicateClass {
	GTypeClass parent_class;
	void (*finalize) (Indicate *self);
};

struct _IndicatePrivate {
	GThread* thread;
	AppIndicator* indicator;
	GtkMenu* menu;
	GtkMenuItem* how_many;
	UpdateChecker* checker;
};

typedef enum  {
	GCONF_INTERFACE_KEY_CHECK_INTERVAL,
	GCONF_INTERFACE_KEY_UPDATE_TOOL,
	GCONF_INTERFACE_KEY_NOTIFY,
	GCONF_INTERFACE_KEY_MANAGER_POPUP,
	GCONF_INTERFACE_KEY_SHOW_PASSIVE_ICON,
	GCONF_INTERFACE_KEY_SHOW_NUMBER_OF_UPDATES
} GConfInterfaceKey;

struct _ParamSpecIndicate {
	GParamSpec parent_instance;
};


static gpointer indicate_parent_class = NULL;

gpointer indicate_ref (gpointer instance);
void indicate_unref (gpointer instance);
GParamSpec* param_spec_indicate (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_indicate (GValue* value, gpointer v_object);
void value_take_indicate (GValue* value, gpointer v_object);
gpointer value_get_indicate (const GValue* value);
GType indicate_get_type (void) G_GNUC_CONST;
gpointer update_checker_ref (gpointer instance);
void update_checker_unref (gpointer instance);
GParamSpec* param_spec_update_checker (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_update_checker (GValue* value, gpointer v_object);
void value_take_update_checker (GValue* value, gpointer v_object);
gpointer value_get_update_checker (const GValue* value);
GType update_checker_get_type (void) G_GNUC_CONST;
#define INDICATE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_INDICATE, IndicatePrivate))
enum  {
	INDICATE_DUMMY_PROPERTY
};
#define INDICATE_ACTIVE_ICON "/usr/local/share/update_indicator/software-update-available.png"
#define INDICATE_ACTIVE_ICON_EMPTY "/usr/local/share/update_indicator/software-update-available-empty.png"
#define INDICATE_PASSIVE_ICON "/usr/local/share/update_indicator/no-update-available.png"
#define INDICATE_GLADE_FILE "/usr/local/share/update_indicator/UpdateIndicator.glade"
Indicate* indicate_new (void);
Indicate* indicate_construct (GType object_type);
GType gconf_interface_key_get_type (void) G_GNUC_CONST;
gint gconf_interface_get_int (GConfInterfaceKey key);
gboolean gconf_interface_get_bool (GConfInterfaceKey key);
UpdateChecker* update_checker_new (gint update_interval);
UpdateChecker* update_checker_construct (GType object_type, gint update_interval);
static void indicate_on_update (Indicate* self, UpdateChecker* sender, gchar** packages, int packages_length1, gint count);
static void _indicate_on_update_update_checker_update_event (UpdateChecker* _sender, gchar** packages, int packages_length1, gint count, gpointer self);
static void indicate_build_menu (Indicate* self);
void* update_checker_check_for_updates (UpdateChecker* self);
static gpointer _update_checker_check_for_updates_gthread_func (gpointer self);
static void indicate_on_execute_clicked (Indicate* self, GtkWidget* sender);
static void _indicate_on_execute_clicked_gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void indicate_on_refresh_clicked (Indicate* self, GtkWidget* sender);
static void _indicate_on_refresh_clicked_gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void indicate_on_preferences_clicked (Indicate* self, GtkWidget* sender);
static void _indicate_on_preferences_clicked_gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void indicate_on_about_clicked (Indicate* self, GtkWidget* sender);
static void _indicate_on_about_clicked_gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void _gtk_main_quit_gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void indicate_set_active_icon (Indicate* self, gint count);
PreferencesDialog* preferences_dialog_new (void);
PreferencesDialog* preferences_dialog_construct (GType object_type);
gpointer preferences_dialog_ref (gpointer instance);
void preferences_dialog_unref (gpointer instance);
GParamSpec* param_spec_preferences_dialog (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_preferences_dialog (GValue* value, gpointer v_object);
void value_take_preferences_dialog (GValue* value, gpointer v_object);
gpointer value_get_preferences_dialog (const GValue* value);
GType preferences_dialog_get_type (void) G_GNUC_CONST;
void indicate_on_preferences_update (Indicate* self, PreferencesDialog* sender);
static void _indicate_on_preferences_update_preferences_dialog_preferences_update (PreferencesDialog* _sender, gpointer self);
void preferences_dialog_show (PreferencesDialog* self);
void update_checker_set_update_interval (UpdateChecker* self, gint value);
gint update_checker_get_count (UpdateChecker* self);
static void indicate_finalize (Indicate* obj);


static void _indicate_on_update_update_checker_update_event (UpdateChecker* _sender, gchar** packages, int packages_length1, gint count, gpointer self) {
	indicate_on_update (self, _sender, packages, packages_length1, count);
}


static gpointer _update_checker_check_for_updates_gthread_func (gpointer self) {
	gpointer result;
	result = update_checker_check_for_updates (self);
	return result;
}


Indicate* indicate_construct (GType object_type) {
	Indicate* self = NULL;
	gint _tmp0_ = 0;
	gint check_interval;
	AppIndicator* _tmp1_;
	AppIndicator* _tmp2_;
	AppIndicatorStatus _tmp3_ = 0;
	gboolean _tmp4_ = FALSE;
	AppIndicator* _tmp5_;
	AppIndicatorStatus _tmp6_;
	gint _tmp7_;
	UpdateChecker* _tmp8_;
	UpdateChecker* _tmp9_;
	gboolean _tmp10_ = FALSE;
	GError * _inner_error_ = NULL;
	self = (Indicate*) g_type_create_instance (object_type);
	_tmp0_ = gconf_interface_get_int (GCONF_INTERFACE_KEY_CHECK_INTERVAL);
	check_interval = _tmp0_;
	_tmp1_ = app_indicator_new ("Update Indicator", "no-update-available", APP_INDICATOR_CATEGORY_APPLICATION_STATUS);
	_g_object_unref0 (self->priv->indicator);
	self->priv->indicator = _tmp1_;
	_tmp2_ = self->priv->indicator;
	app_indicator_set_icon (_tmp2_, INDICATE_PASSIVE_ICON);
	_tmp4_ = gconf_interface_get_bool (GCONF_INTERFACE_KEY_SHOW_PASSIVE_ICON);
	if (_tmp4_) {
		_tmp3_ = APP_INDICATOR_STATUS_ACTIVE;
	} else {
		_tmp3_ = APP_INDICATOR_STATUS_PASSIVE;
	}
	_tmp5_ = self->priv->indicator;
	_tmp6_ = _tmp3_;
	app_indicator_set_status (_tmp5_, _tmp6_);
	_tmp7_ = check_interval;
	_tmp8_ = update_checker_new (_tmp7_);
	_update_checker_unref0 (self->priv->checker);
	self->priv->checker = _tmp8_;
	_tmp9_ = self->priv->checker;
	g_signal_connect (_tmp9_, "update-event", (GCallback) _indicate_on_update_update_checker_update_event, self);
	indicate_build_menu (self);
	_tmp10_ = g_thread_supported ();
	if (_tmp10_) {
		{
			UpdateChecker* _tmp11_;
			GThread* _tmp12_ = NULL;
			GThread* _tmp13_;
			_tmp11_ = self->priv->checker;
			_tmp12_ = g_thread_create (_update_checker_check_for_updates_gthread_func, _tmp11_, FALSE, &_inner_error_);
			_tmp13_ = _tmp12_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == G_THREAD_ERROR) {
					goto __catch0_g_thread_error;
				}
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
			self->priv->thread = _tmp13_;
		}
		goto __finally0;
		__catch0_g_thread_error:
		{
			GError* e = NULL;
			FILE* _tmp14_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp14_ = stderr;
			fprintf (_tmp14_, "Couldn't create thread\n");
			_g_error_free0 (e);
		}
		__finally0:
		if (_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	} else {
		FILE* _tmp15_;
		_tmp15_ = stderr;
		fprintf (_tmp15_, "Threading not supported. Aborting...\n");
		gtk_main_quit ();
	}
	notify_init ("Update Indicator");
	return self;
}


Indicate* indicate_new (void) {
	return indicate_construct (TYPE_INDICATE);
}


static void _indicate_on_execute_clicked_gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	indicate_on_execute_clicked (self, _sender);
}


static void _indicate_on_refresh_clicked_gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	indicate_on_refresh_clicked (self, _sender);
}


static void _indicate_on_preferences_clicked_gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	indicate_on_preferences_clicked (self, _sender);
}


static void _indicate_on_about_clicked_gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	indicate_on_about_clicked (self, _sender);
}


static void _gtk_main_quit_gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	gtk_main_quit ();
}


static void indicate_build_menu (Indicate* self) {
	GtkMenu* _tmp0_;
	GtkMenu* _tmp1_;
	GtkMenuItem* _tmp2_;
	GtkMenuItem* _tmp3_;
	GtkMenuItem* _tmp4_;
	GtkImageMenuItem* _tmp5_;
	GtkImageMenuItem* _tmp6_;
	GtkImageMenuItem* menu_execute;
	GtkImageMenuItem* _tmp7_;
	GtkImageMenuItem* _tmp8_;
	GtkImageMenuItem* menu_refresh;
	GtkImageMenuItem* _tmp9_;
	GtkImageMenuItem* _tmp10_;
	GtkImageMenuItem* menu_preferences;
	GtkImageMenuItem* _tmp11_;
	GtkImageMenuItem* _tmp12_;
	GtkImageMenuItem* menu_about;
	GtkImageMenuItem* _tmp13_;
	GtkImageMenuItem* _tmp14_;
	GtkImageMenuItem* menu_quit;
	GtkMenu* _tmp15_;
	GtkMenuItem* _tmp16_;
	GtkMenu* _tmp17_;
	GtkSeparatorMenuItem* _tmp18_;
	GtkSeparatorMenuItem* _tmp19_;
	GtkMenu* _tmp20_;
	GtkMenu* _tmp21_;
	GtkMenu* _tmp22_;
	GtkMenu* _tmp23_;
	GtkSeparatorMenuItem* _tmp24_;
	GtkSeparatorMenuItem* _tmp25_;
	GtkMenu* _tmp26_;
	GtkMenu* _tmp27_;
	GtkMenu* _tmp28_;
	AppIndicator* _tmp29_;
	GtkMenu* _tmp30_;
	g_return_if_fail (self != NULL);
	_tmp0_ = (GtkMenu*) gtk_menu_new ();
	_tmp1_ = g_object_ref_sink (_tmp0_);
	_g_object_unref0 (self->priv->menu);
	self->priv->menu = _tmp1_;
	_tmp2_ = (GtkMenuItem*) gtk_menu_item_new_with_label ("No updates available");
	_tmp3_ = g_object_ref_sink (_tmp2_);
	_g_object_unref0 (self->priv->how_many);
	self->priv->how_many = _tmp3_;
	_tmp4_ = self->priv->how_many;
	gtk_widget_set_sensitive ((GtkWidget*) _tmp4_, FALSE);
	_tmp5_ = (GtkImageMenuItem*) gtk_image_menu_item_new_from_stock (GTK_STOCK_EXECUTE, NULL);
	_tmp6_ = g_object_ref_sink (_tmp5_);
	menu_execute = _tmp6_;
	g_signal_connect ((GtkMenuItem*) menu_execute, "activate", (GCallback) _indicate_on_execute_clicked_gtk_menu_item_activate, self);
	_tmp7_ = (GtkImageMenuItem*) gtk_image_menu_item_new_from_stock (GTK_STOCK_REFRESH, NULL);
	_tmp8_ = g_object_ref_sink (_tmp7_);
	menu_refresh = _tmp8_;
	g_signal_connect ((GtkMenuItem*) menu_refresh, "activate", (GCallback) _indicate_on_refresh_clicked_gtk_menu_item_activate, self);
	_tmp9_ = (GtkImageMenuItem*) gtk_image_menu_item_new_from_stock (GTK_STOCK_PREFERENCES, NULL);
	_tmp10_ = g_object_ref_sink (_tmp9_);
	menu_preferences = _tmp10_;
	g_signal_connect ((GtkMenuItem*) menu_preferences, "activate", (GCallback) _indicate_on_preferences_clicked_gtk_menu_item_activate, self);
	_tmp11_ = (GtkImageMenuItem*) gtk_image_menu_item_new_from_stock (GTK_STOCK_ABOUT, NULL);
	_tmp12_ = g_object_ref_sink (_tmp11_);
	menu_about = _tmp12_;
	g_signal_connect ((GtkMenuItem*) menu_about, "activate", (GCallback) _indicate_on_about_clicked_gtk_menu_item_activate, self);
	_tmp13_ = (GtkImageMenuItem*) gtk_image_menu_item_new_from_stock (GTK_STOCK_QUIT, NULL);
	_tmp14_ = g_object_ref_sink (_tmp13_);
	menu_quit = _tmp14_;
	g_signal_connect ((GtkMenuItem*) menu_quit, "activate", (GCallback) _gtk_main_quit_gtk_menu_item_activate, NULL);
	_tmp15_ = self->priv->menu;
	_tmp16_ = self->priv->how_many;
	gtk_container_add ((GtkContainer*) _tmp15_, (GtkWidget*) _tmp16_);
	_tmp17_ = self->priv->menu;
	_tmp18_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
	_tmp19_ = g_object_ref_sink (_tmp18_);
	gtk_container_add ((GtkContainer*) _tmp17_, (GtkWidget*) _tmp19_);
	_g_object_unref0 (_tmp19_);
	_tmp20_ = self->priv->menu;
	gtk_container_add ((GtkContainer*) _tmp20_, (GtkWidget*) menu_execute);
	_tmp21_ = self->priv->menu;
	gtk_container_add ((GtkContainer*) _tmp21_, (GtkWidget*) menu_refresh);
	_tmp22_ = self->priv->menu;
	gtk_container_add ((GtkContainer*) _tmp22_, (GtkWidget*) menu_preferences);
	_tmp23_ = self->priv->menu;
	_tmp24_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
	_tmp25_ = g_object_ref_sink (_tmp24_);
	gtk_container_add ((GtkContainer*) _tmp23_, (GtkWidget*) _tmp25_);
	_g_object_unref0 (_tmp25_);
	_tmp26_ = self->priv->menu;
	gtk_container_add ((GtkContainer*) _tmp26_, (GtkWidget*) menu_about);
	_tmp27_ = self->priv->menu;
	gtk_container_add ((GtkContainer*) _tmp27_, (GtkWidget*) menu_quit);
	_tmp28_ = self->priv->menu;
	gtk_widget_show_all ((GtkWidget*) _tmp28_);
	_tmp29_ = self->priv->indicator;
	_tmp30_ = self->priv->menu;
	app_indicator_set_menu (_tmp29_, _tmp30_);
	_g_object_unref0 (menu_quit);
	_g_object_unref0 (menu_about);
	_g_object_unref0 (menu_preferences);
	_g_object_unref0 (menu_refresh);
	_g_object_unref0 (menu_execute);
}


static void indicate_on_update (Indicate* self, UpdateChecker* sender, gchar** packages, int packages_length1, gint count) {
	GtkMenuItem* _tmp0_;
	GtkWidget* _tmp1_ = NULL;
	gint _tmp5_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (sender != NULL);
	_tmp0_ = self->priv->how_many;
	_tmp1_ = gtk_menu_item_get_submenu (_tmp0_);
	if (_tmp1_ != NULL) {
		GtkMenuItem* _tmp2_;
		GtkMenu* _tmp3_;
		GtkMenu* _tmp4_;
		_tmp2_ = self->priv->how_many;
		_tmp3_ = (GtkMenu*) gtk_menu_new ();
		_tmp4_ = g_object_ref_sink (_tmp3_);
		gtk_menu_item_set_submenu (_tmp2_, _tmp4_);
		_g_object_unref0 (_tmp4_);
	}
	_tmp5_ = count;
	if (_tmp5_ > 0) {
		gint _tmp6_;
		AppIndicator* _tmp7_;
		const gchar* _tmp8_ = NULL;
		gint _tmp9_;
		GtkMenuItem* _tmp10_;
		gint _tmp11_;
		gchar* _tmp12_ = NULL;
		gchar* _tmp13_;
		const gchar* _tmp14_;
		gchar* _tmp15_;
		gchar* _tmp16_;
		GtkMenuItem* _tmp17_;
		GtkMenu* _tmp18_;
		GtkMenu* _tmp19_;
		GtkMenu* submenu_how_many;
		gchar** _tmp20_;
		gint _tmp20__length1;
		GtkMenuItem* _tmp26_;
		GtkMenu* _tmp27_;
		GtkMenu* _tmp28_;
		gboolean _tmp29_ = FALSE;
		_tmp6_ = count;
		indicate_set_active_icon (self, _tmp6_);
		_tmp7_ = self->priv->indicator;
		app_indicator_set_status (_tmp7_, APP_INDICATOR_STATUS_ACTIVE);
		_tmp9_ = count;
		if (_tmp9_ == 1) {
			_tmp8_ = " update";
		} else {
			_tmp8_ = " updates";
		}
		_tmp10_ = self->priv->how_many;
		_tmp11_ = count;
		_tmp12_ = g_strdup_printf ("%i", _tmp11_);
		_tmp13_ = _tmp12_;
		_tmp14_ = _tmp8_;
		_tmp15_ = g_strconcat (_tmp13_, _tmp14_, NULL);
		_tmp16_ = _tmp15_;
		gtk_menu_item_set_label (_tmp10_, _tmp16_);
		_g_free0 (_tmp16_);
		_g_free0 (_tmp13_);
		_tmp17_ = self->priv->how_many;
		gtk_widget_set_sensitive ((GtkWidget*) _tmp17_, TRUE);
		_tmp18_ = (GtkMenu*) gtk_menu_new ();
		_tmp19_ = g_object_ref_sink (_tmp18_);
		submenu_how_many = _tmp19_;
		_tmp20_ = packages;
		_tmp20__length1 = packages_length1;
		{
			gchar** package_collection = NULL;
			gint package_collection_length1 = 0;
			gint _package_collection_size_ = 0;
			gint package_it = 0;
			package_collection = _tmp20_;
			package_collection_length1 = _tmp20__length1;
			for (package_it = 0; package_it < _tmp20__length1; package_it = package_it + 1) {
				gchar* _tmp21_;
				gchar* package = NULL;
				_tmp21_ = g_strdup (package_collection[package_it]);
				package = _tmp21_;
				{
					GtkMenu* _tmp22_;
					const gchar* _tmp23_;
					GtkMenuItem* _tmp24_;
					GtkMenuItem* _tmp25_;
					_tmp22_ = submenu_how_many;
					_tmp23_ = package;
					_tmp24_ = (GtkMenuItem*) gtk_menu_item_new_with_label (_tmp23_);
					_tmp25_ = g_object_ref_sink (_tmp24_);
					gtk_container_add ((GtkContainer*) _tmp22_, (GtkWidget*) _tmp25_);
					_g_object_unref0 (_tmp25_);
					_g_free0 (package);
				}
			}
		}
		_tmp26_ = self->priv->how_many;
		_tmp27_ = submenu_how_many;
		gtk_menu_item_set_submenu (_tmp26_, _tmp27_);
		_tmp28_ = submenu_how_many;
		gtk_widget_show_all ((GtkWidget*) _tmp28_);
		_tmp29_ = gconf_interface_get_bool (GCONF_INTERFACE_KEY_NOTIFY);
		if (_tmp29_) {
			gchar* _tmp30_;
			gchar* package_list;
			gchar** _tmp31_;
			gint _tmp31__length1;
			const gchar* _tmp46_ = NULL;
			gint _tmp47_;
			gint _tmp48_;
			gchar* _tmp49_ = NULL;
			gchar* _tmp50_;
			gchar* _tmp51_;
			gchar* _tmp52_;
			const gchar* _tmp53_;
			gchar* _tmp54_;
			gchar* _tmp55_;
			gchar* _tmp56_;
			gchar* _tmp57_;
			const gchar* _tmp58_;
			NotifyNotification* _tmp59_;
			NotifyNotification* _tmp60_;
			NotifyNotification* notify;
			_tmp30_ = g_strdup ("");
			package_list = _tmp30_;
			_tmp31_ = packages;
			_tmp31__length1 = packages_length1;
			{
				gchar** package_collection = NULL;
				gint package_collection_length1 = 0;
				gint _package_collection_size_ = 0;
				gint package_it = 0;
				package_collection = _tmp31_;
				package_collection_length1 = _tmp31__length1;
				for (package_it = 0; package_it < _tmp31__length1; package_it = package_it + 1) {
					gchar* _tmp32_;
					gchar* package = NULL;
					_tmp32_ = g_strdup (package_collection[package_it]);
					package = _tmp32_;
					{
						const gchar* _tmp33_ = NULL;
						const gchar* _tmp34_;
						gchar** _tmp35_;
						gint _tmp35__length1;
						gint _tmp36_;
						const gchar* _tmp37_;
						const gchar* _tmp38_;
						const gchar* _tmp39_;
						gchar* _tmp40_;
						gchar* _tmp41_;
						const gchar* _tmp42_;
						gchar* _tmp43_;
						gchar* _tmp44_;
						gchar* _tmp45_;
						_tmp34_ = package;
						_tmp35_ = packages;
						_tmp35__length1 = packages_length1;
						_tmp36_ = count;
						_tmp37_ = _tmp35_[_tmp36_ - 1];
						if (g_strcmp0 (_tmp34_, _tmp37_) == 0) {
							_tmp33_ = "";
						} else {
							_tmp33_ = "\n";
						}
						_tmp38_ = package_list;
						_tmp39_ = package;
						_tmp40_ = g_strconcat ("- ", _tmp39_, NULL);
						_tmp41_ = _tmp40_;
						_tmp42_ = _tmp33_;
						_tmp43_ = g_strconcat (_tmp41_, _tmp42_, NULL);
						_tmp44_ = _tmp43_;
						_tmp45_ = g_strconcat (_tmp38_, _tmp44_, NULL);
						_g_free0 (package_list);
						package_list = _tmp45_;
						_g_free0 (_tmp44_);
						_g_free0 (_tmp41_);
						_g_free0 (package);
					}
				}
			}
			_tmp47_ = count;
			if (_tmp47_ == 1) {
				_tmp46_ = "update";
			} else {
				_tmp46_ = "updates";
			}
			_tmp48_ = count;
			_tmp49_ = g_strdup_printf ("%i", _tmp48_);
			_tmp50_ = _tmp49_;
			_tmp51_ = g_strconcat (_tmp50_, " new ", NULL);
			_tmp52_ = _tmp51_;
			_tmp53_ = _tmp46_;
			_tmp54_ = g_strconcat (_tmp52_, _tmp53_, NULL);
			_tmp55_ = _tmp54_;
			_tmp56_ = g_strconcat (_tmp55_, " available", NULL);
			_tmp57_ = _tmp56_;
			_tmp58_ = package_list;
			_tmp59_ = notify_notification_new (_tmp57_, _tmp58_, INDICATE_ACTIVE_ICON);
			_tmp60_ = _tmp59_;
			_g_free0 (_tmp57_);
			_g_free0 (_tmp55_);
			_g_free0 (_tmp52_);
			_g_free0 (_tmp50_);
			notify = _tmp60_;
			{
				NotifyNotification* _tmp61_;
				_tmp61_ = notify;
				notify_notification_show (_tmp61_, &_inner_error_);
				if (_inner_error_ != NULL) {
					goto __catch1_g_error;
				}
			}
			goto __finally1;
			__catch1_g_error:
			{
				GError* e = NULL;
				FILE* _tmp62_;
				GError* _tmp63_;
				const gchar* _tmp64_;
				e = _inner_error_;
				_inner_error_ = NULL;
				_tmp62_ = stderr;
				_tmp63_ = e;
				_tmp64_ = _tmp63_->message;
				fprintf (_tmp62_, "Could not show notification: %s\n", _tmp64_);
				_g_error_free0 (e);
			}
			__finally1:
			if (_inner_error_ != NULL) {
				_g_object_unref0 (notify);
				_g_free0 (package_list);
				_g_object_unref0 (submenu_how_many);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
			_g_object_unref0 (notify);
			_g_free0 (package_list);
		}
		_g_object_unref0 (submenu_how_many);
	} else {
		AppIndicator* _tmp65_;
		AppIndicatorStatus _tmp66_ = 0;
		gboolean _tmp67_ = FALSE;
		AppIndicator* _tmp68_;
		AppIndicatorStatus _tmp69_;
		GtkMenuItem* _tmp70_;
		GtkMenuItem* _tmp71_;
		gboolean _tmp72_ = FALSE;
		_tmp65_ = self->priv->indicator;
		app_indicator_set_icon (_tmp65_, INDICATE_PASSIVE_ICON);
		_tmp67_ = gconf_interface_get_bool (GCONF_INTERFACE_KEY_SHOW_PASSIVE_ICON);
		if (_tmp67_) {
			_tmp66_ = APP_INDICATOR_STATUS_ACTIVE;
		} else {
			_tmp66_ = APP_INDICATOR_STATUS_PASSIVE;
		}
		_tmp68_ = self->priv->indicator;
		_tmp69_ = _tmp66_;
		app_indicator_set_status (_tmp68_, _tmp69_);
		_tmp70_ = self->priv->how_many;
		gtk_menu_item_set_label (_tmp70_, "No updates available");
		_tmp71_ = self->priv->how_many;
		gtk_widget_set_sensitive ((GtkWidget*) _tmp71_, FALSE);
		_tmp72_ = gconf_interface_get_bool (GCONF_INTERFACE_KEY_NOTIFY);
		if (_tmp72_) {
			NotifyNotification* _tmp73_;
			NotifyNotification* notify;
			_tmp73_ = notify_notification_new ("Updates installed", "Your system is now up-to-date", INDICATE_PASSIVE_ICON);
			notify = _tmp73_;
			{
				NotifyNotification* _tmp74_;
				_tmp74_ = notify;
				notify_notification_show (_tmp74_, &_inner_error_);
				if (_inner_error_ != NULL) {
					goto __catch2_g_error;
				}
			}
			goto __finally2;
			__catch2_g_error:
			{
				GError* e = NULL;
				FILE* _tmp75_;
				GError* _tmp76_;
				const gchar* _tmp77_;
				e = _inner_error_;
				_inner_error_ = NULL;
				_tmp75_ = stderr;
				_tmp76_ = e;
				_tmp77_ = _tmp76_->message;
				fprintf (_tmp75_, "Could not show notification: %s\n", _tmp77_);
				_g_error_free0 (e);
			}
			__finally2:
			if (_inner_error_ != NULL) {
				_g_object_unref0 (notify);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
			_g_object_unref0 (notify);
		}
	}
}


static void indicate_set_active_icon (Indicate* self, gint count) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = gconf_interface_get_bool (GCONF_INTERFACE_KEY_SHOW_NUMBER_OF_UPDATES);
	if (_tmp0_) {
		cairo_surface_t* _tmp1_;
		cairo_surface_t* icon;
		cairo_surface_t* _tmp2_;
		cairo_t* _tmp3_;
		cairo_t* co;
		cairo_text_extents_t ex = {0};
		cairo_t* _tmp4_;
		cairo_t* _tmp5_;
		cairo_t* _tmp6_;
		cairo_t* _tmp7_;
		gint _tmp8_;
		gchar* _tmp9_ = NULL;
		gchar* _tmp10_;
		cairo_text_extents_t _tmp11_ = {0};
		cairo_t* _tmp12_;
		cairo_text_extents_t _tmp13_;
		gdouble _tmp14_;
		cairo_text_extents_t _tmp15_;
		gdouble _tmp16_;
		cairo_t* _tmp17_;
		gint _tmp18_;
		gchar* _tmp19_ = NULL;
		gchar* _tmp20_;
		cairo_surface_t* _tmp21_;
		cairo_surface_t* _tmp22_;
		cairo_surface_t* _tmp23_;
		AppIndicator* _tmp24_;
		AppIndicator* _tmp25_;
		_tmp1_ = cairo_image_surface_create_from_png (INDICATE_ACTIVE_ICON_EMPTY);
		icon = _tmp1_;
		_tmp2_ = icon;
		_tmp3_ = cairo_create (_tmp2_);
		co = _tmp3_;
		memset (&ex, 0, sizeof (cairo_text_extents_t));
		ex.x_bearing = (gdouble) 10;
		ex.width = (gdouble) 10;
		ex.height = (gdouble) 10;
		_tmp4_ = co;
		cairo_set_source_rgb (_tmp4_, 0.2, 0.2, 0.2);
		_tmp5_ = co;
		cairo_select_font_face (_tmp5_, "Ubuntu Mono", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
		_tmp6_ = co;
		cairo_set_font_size (_tmp6_, (gdouble) 20);
		_tmp7_ = co;
		_tmp8_ = count;
		_tmp9_ = g_strdup_printf ("%i", _tmp8_);
		_tmp10_ = _tmp9_;
		cairo_text_extents (_tmp7_, _tmp10_, &_tmp11_);
		ex = _tmp11_;
		_g_free0 (_tmp10_);
		_tmp12_ = co;
		_tmp13_ = ex;
		_tmp14_ = _tmp13_.width;
		_tmp15_ = ex;
		_tmp16_ = _tmp15_.height;
		cairo_move_to (_tmp12_, (24 - 1) - (_tmp14_ / 2), (24 - 1) + (_tmp16_ / 2));
		_tmp17_ = co;
		_tmp18_ = count;
		_tmp19_ = g_strdup_printf ("%i", _tmp18_);
		_tmp20_ = _tmp19_;
		cairo_show_text (_tmp17_, _tmp20_);
		_g_free0 (_tmp20_);
		_tmp21_ = icon;
		cairo_surface_write_to_png (_tmp21_, "/tmp/update_indicator.png");
		_tmp22_ = icon;
		cairo_surface_show_page (_tmp22_);
		_tmp23_ = icon;
		cairo_surface_finish (_tmp23_);
		_tmp24_ = self->priv->indicator;
		app_indicator_set_icon (_tmp24_, INDICATE_ACTIVE_ICON_EMPTY);
		_tmp25_ = self->priv->indicator;
		app_indicator_set_icon (_tmp25_, "/tmp/update_indicator.png");
		_cairo_destroy0 (co);
		_cairo_surface_destroy0 (icon);
	} else {
		AppIndicator* _tmp26_;
		_tmp26_ = self->priv->indicator;
		app_indicator_set_icon (_tmp26_, INDICATE_ACTIVE_ICON);
	}
}


static void indicate_on_execute_clicked (Indicate* self, GtkWidget* sender) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (sender != NULL);
	{
		const gchar* _tmp0_ = NULL;
		gint _tmp1_ = 0;
		const gchar* _tmp2_;
		_tmp1_ = gconf_interface_get_int (GCONF_INTERFACE_KEY_UPDATE_TOOL);
		if (_tmp1_ == 0) {
			_tmp0_ = "update-manager";
		} else {
			_tmp0_ = "gksu \"apt-get upgrade -y\"";
		}
		_tmp2_ = _tmp0_;
		g_spawn_command_line_async (_tmp2_, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch3_g_error;
		}
	}
	goto __finally3;
	__catch3_g_error:
	{
		GError* e = NULL;
		FILE* _tmp3_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp3_ = stderr;
		fprintf (_tmp3_, "Failed to start \"update-manager\"\n");
		_g_error_free0 (e);
	}
	__finally3:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void indicate_on_refresh_clicked (Indicate* self, GtkWidget* sender) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (sender != NULL);
	{
		g_spawn_command_line_async ("gksu apt-get update", &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch4_g_error;
		}
	}
	goto __finally4;
	__catch4_g_error:
	{
		GError* e = NULL;
		FILE* _tmp0_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp0_ = stderr;
		fprintf (_tmp0_, "Failed to refresh package list\n");
		_g_error_free0 (e);
	}
	__finally4:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void _indicate_on_preferences_update_preferences_dialog_preferences_update (PreferencesDialog* _sender, gpointer self) {
	indicate_on_preferences_update (self, _sender);
}


static void indicate_on_preferences_clicked (Indicate* self, GtkWidget* sender) {
	PreferencesDialog* _tmp0_;
	PreferencesDialog* dialog;
	g_return_if_fail (self != NULL);
	g_return_if_fail (sender != NULL);
	_tmp0_ = preferences_dialog_new ();
	dialog = _tmp0_;
	g_signal_connect (dialog, "preferences-update", (GCallback) _indicate_on_preferences_update_preferences_dialog_preferences_update, self);
	preferences_dialog_show (dialog);
	_preferences_dialog_unref0 (dialog);
}


void indicate_on_preferences_update (Indicate* self, PreferencesDialog* sender) {
	UpdateChecker* _tmp0_;
	gint _tmp1_ = 0;
	UpdateChecker* _tmp2_;
	gint _tmp3_;
	gint _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (sender != NULL);
	_tmp0_ = self->priv->checker;
	_tmp1_ = gconf_interface_get_int (GCONF_INTERFACE_KEY_CHECK_INTERVAL);
	update_checker_set_update_interval (_tmp0_, _tmp1_);
	_tmp2_ = self->priv->checker;
	_tmp3_ = update_checker_get_count (_tmp2_);
	_tmp4_ = _tmp3_;
	if (_tmp4_ == 0) {
		gboolean _tmp5_ = FALSE;
		_tmp5_ = gconf_interface_get_bool (GCONF_INTERFACE_KEY_SHOW_PASSIVE_ICON);
		if (_tmp5_) {
			AppIndicator* _tmp6_;
			_tmp6_ = self->priv->indicator;
			app_indicator_set_status (_tmp6_, APP_INDICATOR_STATUS_ACTIVE);
		} else {
			AppIndicator* _tmp7_;
			_tmp7_ = self->priv->indicator;
			app_indicator_set_status (_tmp7_, APP_INDICATOR_STATUS_PASSIVE);
		}
	} else {
		UpdateChecker* _tmp8_;
		gint _tmp9_;
		gint _tmp10_;
		_tmp8_ = self->priv->checker;
		_tmp9_ = update_checker_get_count (_tmp8_);
		_tmp10_ = _tmp9_;
		indicate_set_active_icon (self, _tmp10_);
	}
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void indicate_on_about_clicked (Indicate* self, GtkWidget* sender) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (sender != NULL);
	{
		GtkBuilder* _tmp0_;
		GtkBuilder* builder;
		GObject* _tmp1_ = NULL;
		GtkDialog* _tmp2_;
		GtkDialog* dialog;
		GtkDialog* _tmp3_;
		GtkDialog* _tmp4_;
		_tmp0_ = gtk_builder_new ();
		builder = _tmp0_;
		gtk_builder_add_from_file (builder, INDICATE_GLADE_FILE, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_object_unref0 (builder);
			goto __catch5_g_error;
		}
		_tmp1_ = gtk_builder_get_object (builder, "about_dialog");
		_tmp2_ = _g_object_ref0 (GTK_IS_DIALOG (_tmp1_) ? ((GtkDialog*) _tmp1_) : NULL);
		dialog = _tmp2_;
		_tmp3_ = dialog;
		gtk_dialog_run (_tmp3_);
		_tmp4_ = dialog;
		gtk_widget_hide ((GtkWidget*) _tmp4_);
		_g_object_unref0 (dialog);
		_g_object_unref0 (builder);
	}
	goto __finally5;
	__catch5_g_error:
	{
		GError* e = NULL;
		FILE* _tmp5_;
		GError* _tmp6_;
		const gchar* _tmp7_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp5_ = stderr;
		_tmp6_ = e;
		_tmp7_ = _tmp6_->message;
		fprintf (_tmp5_, "Error: Couldn't load about dialog: %s'\n", _tmp7_);
		_g_error_free0 (e);
	}
	__finally5:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void value_indicate_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_indicate_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		indicate_unref (value->data[0].v_pointer);
	}
}


static void value_indicate_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = indicate_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_indicate_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_indicate_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Indicate* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = indicate_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_indicate_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Indicate** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = indicate_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_indicate (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecIndicate* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_INDICATE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_indicate (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_INDICATE), NULL);
	return value->data[0].v_pointer;
}


void value_set_indicate (GValue* value, gpointer v_object) {
	Indicate* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_INDICATE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_INDICATE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		indicate_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		indicate_unref (old);
	}
}


void value_take_indicate (GValue* value, gpointer v_object) {
	Indicate* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_INDICATE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_INDICATE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		indicate_unref (old);
	}
}


static void indicate_class_init (IndicateClass * klass) {
	indicate_parent_class = g_type_class_peek_parent (klass);
	INDICATE_CLASS (klass)->finalize = indicate_finalize;
	g_type_class_add_private (klass, sizeof (IndicatePrivate));
}


static void indicate_instance_init (Indicate * self) {
	self->priv = INDICATE_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void indicate_finalize (Indicate* obj) {
	Indicate * self;
	self = INDICATE (obj);
	_g_object_unref0 (self->priv->indicator);
	_g_object_unref0 (self->priv->menu);
	_g_object_unref0 (self->priv->how_many);
	_update_checker_unref0 (self->priv->checker);
}


GType indicate_get_type (void) {
	static volatile gsize indicate_type_id__volatile = 0;
	if (g_once_init_enter (&indicate_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_indicate_init, value_indicate_free_value, value_indicate_copy_value, value_indicate_peek_pointer, "p", value_indicate_collect_value, "p", value_indicate_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (IndicateClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) indicate_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Indicate), 0, (GInstanceInitFunc) indicate_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType indicate_type_id;
		indicate_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Indicate", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&indicate_type_id__volatile, indicate_type_id);
	}
	return indicate_type_id__volatile;
}


gpointer indicate_ref (gpointer instance) {
	Indicate* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void indicate_unref (gpointer instance) {
	Indicate* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		INDICATE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



