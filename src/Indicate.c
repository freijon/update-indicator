/* Indicate.c generated by valac 0.14.0, the Vala compiler
 * generated from Indicate.vala, do not modify */

/*  */
/*  Indicate.vala*/
/*  */
/*  Author:*/
/*       Jonas Frei <freijon@gmail.com>*/
/* */
/*  Copyright (c) 2011 Jonas Frei*/
/* */
/*  This program is free software: you can redistribute it and/or modify*/
/*  it under the terms of the GNU General Public License as published by*/
/*  the Free Software Foundation, either version 3 of the License, or*/
/*  (at your option) any later version.*/
/* */
/*  This program is distributed in the hope that it will be useful,*/
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of*/
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the*/
/*  GNU General Public License for more details.*/
/* */
/*  You should have received a copy of the GNU General Public License*/
/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.*/

#include <glib.h>
#include <glib-object.h>
#include <libappindicator/app-indicator.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <libnotify/notify.h>
#include <cairo.h>
#include <float.h>
#include <math.h>
#include <gobject/gvaluecollector.h>


#define TYPE_INDICATE (indicate_get_type ())
#define INDICATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_INDICATE, Indicate))
#define INDICATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_INDICATE, IndicateClass))
#define IS_INDICATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_INDICATE))
#define IS_INDICATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_INDICATE))
#define INDICATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_INDICATE, IndicateClass))

typedef struct _Indicate Indicate;
typedef struct _IndicateClass IndicateClass;
typedef struct _IndicatePrivate IndicatePrivate;

#define TYPE_UPDATE_CHECKER (update_checker_get_type ())
#define UPDATE_CHECKER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_UPDATE_CHECKER, UpdateChecker))
#define UPDATE_CHECKER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_UPDATE_CHECKER, UpdateCheckerClass))
#define IS_UPDATE_CHECKER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_UPDATE_CHECKER))
#define IS_UPDATE_CHECKER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_UPDATE_CHECKER))
#define UPDATE_CHECKER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_UPDATE_CHECKER, UpdateCheckerClass))

typedef struct _UpdateChecker UpdateChecker;
typedef struct _UpdateCheckerClass UpdateCheckerClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _update_checker_unref0(var) ((var == NULL) ? NULL : (var = (update_checker_unref (var), NULL)))

#define GCONF_INTERFACE_TYPE_KEY (gconf_interface_key_get_type ())
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _cairo_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_destroy (var), NULL)))
#define _cairo_surface_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_surface_destroy (var), NULL)))

#define TYPE_PREFERENCES_DIALOG (preferences_dialog_get_type ())
#define PREFERENCES_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PREFERENCES_DIALOG, PreferencesDialog))
#define PREFERENCES_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PREFERENCES_DIALOG, PreferencesDialogClass))
#define IS_PREFERENCES_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PREFERENCES_DIALOG))
#define IS_PREFERENCES_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PREFERENCES_DIALOG))
#define PREFERENCES_DIALOG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PREFERENCES_DIALOG, PreferencesDialogClass))

typedef struct _PreferencesDialog PreferencesDialog;
typedef struct _PreferencesDialogClass PreferencesDialogClass;
#define _preferences_dialog_unref0(var) ((var == NULL) ? NULL : (var = (preferences_dialog_unref (var), NULL)))
typedef struct _ParamSpecIndicate ParamSpecIndicate;

struct _Indicate {
	GTypeInstance parent_instance;
	volatile int ref_count;
	IndicatePrivate * priv;
};

struct _IndicateClass {
	GTypeClass parent_class;
	void (*finalize) (Indicate *self);
};

struct _IndicatePrivate {
	GThread* thread;
	AppIndicator* indicator;
	GtkMenu* menu;
	GtkMenuItem* how_many;
	GtkMenuItem* menu_execute;
	UpdateChecker* checker;
};

typedef enum  {
	GCONF_INTERFACE_KEY_CHECK_INTERVAL,
	GCONF_INTERFACE_KEY_UPDATE_TOOL,
	GCONF_INTERFACE_KEY_NOTIFY,
	GCONF_INTERFACE_KEY_MANAGER_POPUP,
	GCONF_INTERFACE_KEY_SHOW_PASSIVE_ICON,
	GCONF_INTERFACE_KEY_SHOW_NUMBER_OF_UPDATES
} GConfInterfaceKey;

struct _ParamSpecIndicate {
	GParamSpec parent_instance;
};


static gpointer indicate_parent_class = NULL;

gpointer indicate_ref (gpointer instance);
void indicate_unref (gpointer instance);
GParamSpec* param_spec_indicate (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_indicate (GValue* value, gpointer v_object);
void value_take_indicate (GValue* value, gpointer v_object);
gpointer value_get_indicate (const GValue* value);
GType indicate_get_type (void) G_GNUC_CONST;
gpointer update_checker_ref (gpointer instance);
void update_checker_unref (gpointer instance);
GParamSpec* param_spec_update_checker (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_update_checker (GValue* value, gpointer v_object);
void value_take_update_checker (GValue* value, gpointer v_object);
gpointer value_get_update_checker (const GValue* value);
GType update_checker_get_type (void) G_GNUC_CONST;
#define INDICATE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_INDICATE, IndicatePrivate))
enum  {
	INDICATE_DUMMY_PROPERTY
};
#define INDICATE_ACTIVE_ICON "/usr/local/share/update_indicator/software-update-available.png"
#define INDICATE_ACTIVE_ICON_EMPTY "/usr/local/share/update_indicator/software-update-available-empty.png"
#define INDICATE_PASSIVE_ICON "/usr/local/share/update_indicator/no-update-available.png"
#define INDICATE_GLADE_FILE "/usr/local/share/update_indicator/UpdateIndicator.glade"
Indicate* indicate_new (void);
Indicate* indicate_construct (GType object_type);
GType gconf_interface_key_get_type (void) G_GNUC_CONST;
gint gconf_interface_get_int (GConfInterfaceKey key);
gboolean gconf_interface_get_bool (GConfInterfaceKey key);
UpdateChecker* update_checker_new (gint update_interval);
UpdateChecker* update_checker_construct (GType object_type, gint update_interval);
static void indicate_on_update (Indicate* self, UpdateChecker* sender, gchar** packages, int packages_length1, gint count);
static void _indicate_on_update_update_checker_update_event (UpdateChecker* _sender, gchar** packages, int packages_length1, gint count, gpointer self);
static void indicate_build_menu (Indicate* self);
void* update_checker_check_for_updates (UpdateChecker* self);
static gpointer _update_checker_check_for_updates_gthread_func (gpointer self);
static void indicate_on_execute_clicked (Indicate* self, GtkWidget* sender);
static void _indicate_on_execute_clicked_gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void indicate_on_refresh_clicked (Indicate* self, GtkWidget* sender);
static void _indicate_on_refresh_clicked_gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void indicate_on_preferences_clicked (Indicate* self, GtkWidget* sender);
static void _indicate_on_preferences_clicked_gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void indicate_on_about_clicked (Indicate* self, GtkWidget* sender);
static void _indicate_on_about_clicked_gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void _gtk_main_quit_gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void indicate_set_active_icon (Indicate* self, gint count);
PreferencesDialog* preferences_dialog_new (void);
PreferencesDialog* preferences_dialog_construct (GType object_type);
gpointer preferences_dialog_ref (gpointer instance);
void preferences_dialog_unref (gpointer instance);
GParamSpec* param_spec_preferences_dialog (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_preferences_dialog (GValue* value, gpointer v_object);
void value_take_preferences_dialog (GValue* value, gpointer v_object);
gpointer value_get_preferences_dialog (const GValue* value);
GType preferences_dialog_get_type (void) G_GNUC_CONST;
void indicate_on_preferences_update (Indicate* self, PreferencesDialog* sender);
static void _indicate_on_preferences_update_preferences_dialog_preferences_update (PreferencesDialog* _sender, gpointer self);
void preferences_dialog_show (PreferencesDialog* self);
void update_checker_set_update_interval (UpdateChecker* self, gint value);
gint update_checker_get_count (UpdateChecker* self);
static void indicate_finalize (Indicate* obj);


static void _indicate_on_update_update_checker_update_event (UpdateChecker* _sender, gchar** packages, int packages_length1, gint count, gpointer self) {
	indicate_on_update (self, _sender, packages, packages_length1, count);
}


static gpointer _update_checker_check_for_updates_gthread_func (gpointer self) {
	gpointer result;
	result = update_checker_check_for_updates (self);
	return result;
}


Indicate* indicate_construct (GType object_type) {
	Indicate* self = NULL;
	gint _tmp0_ = 0;
	gint check_interval;
	AppIndicator* _tmp1_;
	AppIndicator* _tmp2_;
	AppIndicatorStatus _tmp3_ = 0;
	gboolean _tmp4_ = FALSE;
	AppIndicator* _tmp5_;
	AppIndicatorStatus _tmp6_;
	gint _tmp7_;
	UpdateChecker* _tmp8_;
	UpdateChecker* _tmp9_;
	gboolean _tmp10_ = FALSE;
	GError * _inner_error_ = NULL;
	self = (Indicate*) g_type_create_instance (object_type);
	_tmp0_ = gconf_interface_get_int (GCONF_INTERFACE_KEY_CHECK_INTERVAL);
	check_interval = _tmp0_;
	_tmp1_ = app_indicator_new ("Update Indicator", "no-update-available", APP_INDICATOR_CATEGORY_APPLICATION_STATUS);
	_g_object_unref0 (self->priv->indicator);
	self->priv->indicator = _tmp1_;
	_tmp2_ = self->priv->indicator;
	app_indicator_set_icon (_tmp2_, INDICATE_PASSIVE_ICON);
	_tmp4_ = gconf_interface_get_bool (GCONF_INTERFACE_KEY_SHOW_PASSIVE_ICON);
	if (_tmp4_) {
		_tmp3_ = APP_INDICATOR_STATUS_ACTIVE;
	} else {
		_tmp3_ = APP_INDICATOR_STATUS_PASSIVE;
	}
	_tmp5_ = self->priv->indicator;
	_tmp6_ = _tmp3_;
	app_indicator_set_status (_tmp5_, _tmp6_);
	_tmp7_ = check_interval;
	_tmp8_ = update_checker_new (_tmp7_);
	_update_checker_unref0 (self->priv->checker);
	self->priv->checker = _tmp8_;
	_tmp9_ = self->priv->checker;
	g_signal_connect (_tmp9_, "update-event", (GCallback) _indicate_on_update_update_checker_update_event, self);
	indicate_build_menu (self);
	_tmp10_ = g_thread_supported ();
	if (_tmp10_) {
		{
			UpdateChecker* _tmp11_;
			GThread* _tmp12_ = NULL;
			GThread* _tmp13_;
			_tmp11_ = self->priv->checker;
			_tmp12_ = g_thread_create (_update_checker_check_for_updates_gthread_func, _tmp11_, FALSE, &_inner_error_);
			_tmp13_ = _tmp12_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == G_THREAD_ERROR) {
					goto __catch0_g_thread_error;
				}
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
			self->priv->thread = _tmp13_;
		}
		goto __finally0;
		__catch0_g_thread_error:
		{
			GError* e = NULL;
			FILE* _tmp14_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp14_ = stderr;
			fprintf (_tmp14_, "Couldn't create thread\n");
			_g_error_free0 (e);
		}
		__finally0:
		if (_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	} else {
		FILE* _tmp15_;
		_tmp15_ = stderr;
		fprintf (_tmp15_, "Threading not supported. Aborting...\n");
		gtk_main_quit ();
	}
	notify_init ("Update Indicator");
	return self;
}


Indicate* indicate_new (void) {
	return indicate_construct (TYPE_INDICATE);
}


static void _indicate_on_execute_clicked_gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	indicate_on_execute_clicked (self, _sender);
}


static void _indicate_on_refresh_clicked_gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	indicate_on_refresh_clicked (self, _sender);
}


static void _indicate_on_preferences_clicked_gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	indicate_on_preferences_clicked (self, _sender);
}


static void _indicate_on_about_clicked_gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	indicate_on_about_clicked (self, _sender);
}


static void _gtk_main_quit_gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	gtk_main_quit ();
}


static void indicate_build_menu (Indicate* self) {
	GtkMenu* _tmp0_;
	GtkMenu* _tmp1_;
	GtkMenuItem* _tmp2_;
	GtkMenuItem* _tmp3_;
	GtkMenuItem* _tmp4_;
	GtkImageMenuItem* _tmp5_;
	GtkMenuItem* _tmp6_;
	GtkMenuItem* _tmp7_;
	GtkMenuItem* _tmp8_;
	GtkImageMenuItem* _tmp9_;
	GtkImageMenuItem* _tmp10_;
	GtkImageMenuItem* menu_refresh;
	GtkImageMenuItem* _tmp11_;
	GtkImageMenuItem* _tmp12_;
	GtkImageMenuItem* menu_preferences;
	GtkImageMenuItem* _tmp13_;
	GtkImageMenuItem* _tmp14_;
	GtkImageMenuItem* menu_about;
	GtkImageMenuItem* _tmp15_;
	GtkImageMenuItem* _tmp16_;
	GtkImageMenuItem* menu_quit;
	GtkMenu* _tmp17_;
	GtkMenuItem* _tmp18_;
	GtkMenu* _tmp19_;
	GtkSeparatorMenuItem* _tmp20_;
	GtkSeparatorMenuItem* _tmp21_;
	GtkMenu* _tmp22_;
	GtkMenuItem* _tmp23_;
	GtkMenu* _tmp24_;
	GtkMenu* _tmp25_;
	GtkMenu* _tmp26_;
	GtkSeparatorMenuItem* _tmp27_;
	GtkSeparatorMenuItem* _tmp28_;
	GtkMenu* _tmp29_;
	GtkMenu* _tmp30_;
	GtkMenu* _tmp31_;
	AppIndicator* _tmp32_;
	GtkMenu* _tmp33_;
	g_return_if_fail (self != NULL);
	_tmp0_ = (GtkMenu*) gtk_menu_new ();
	_tmp1_ = g_object_ref_sink (_tmp0_);
	_g_object_unref0 (self->priv->menu);
	self->priv->menu = _tmp1_;
	_tmp2_ = (GtkMenuItem*) gtk_menu_item_new_with_label ("No updates available");
	_tmp3_ = g_object_ref_sink (_tmp2_);
	_g_object_unref0 (self->priv->how_many);
	self->priv->how_many = _tmp3_;
	_tmp4_ = self->priv->how_many;
	gtk_widget_set_sensitive ((GtkWidget*) _tmp4_, FALSE);
	_tmp5_ = (GtkImageMenuItem*) gtk_image_menu_item_new_from_stock (GTK_STOCK_EXECUTE, NULL);
	_tmp6_ = (GtkMenuItem*) g_object_ref_sink (_tmp5_);
	_g_object_unref0 (self->priv->menu_execute);
	self->priv->menu_execute = _tmp6_;
	_tmp7_ = self->priv->menu_execute;
	g_signal_connect (_tmp7_, "activate", (GCallback) _indicate_on_execute_clicked_gtk_menu_item_activate, self);
	_tmp8_ = self->priv->menu_execute;
	gtk_widget_set_sensitive ((GtkWidget*) _tmp8_, FALSE);
	_tmp9_ = (GtkImageMenuItem*) gtk_image_menu_item_new_from_stock (GTK_STOCK_REFRESH, NULL);
	_tmp10_ = g_object_ref_sink (_tmp9_);
	menu_refresh = _tmp10_;
	g_signal_connect ((GtkMenuItem*) menu_refresh, "activate", (GCallback) _indicate_on_refresh_clicked_gtk_menu_item_activate, self);
	_tmp11_ = (GtkImageMenuItem*) gtk_image_menu_item_new_from_stock (GTK_STOCK_PREFERENCES, NULL);
	_tmp12_ = g_object_ref_sink (_tmp11_);
	menu_preferences = _tmp12_;
	g_signal_connect ((GtkMenuItem*) menu_preferences, "activate", (GCallback) _indicate_on_preferences_clicked_gtk_menu_item_activate, self);
	_tmp13_ = (GtkImageMenuItem*) gtk_image_menu_item_new_from_stock (GTK_STOCK_ABOUT, NULL);
	_tmp14_ = g_object_ref_sink (_tmp13_);
	menu_about = _tmp14_;
	g_signal_connect ((GtkMenuItem*) menu_about, "activate", (GCallback) _indicate_on_about_clicked_gtk_menu_item_activate, self);
	_tmp15_ = (GtkImageMenuItem*) gtk_image_menu_item_new_from_stock (GTK_STOCK_QUIT, NULL);
	_tmp16_ = g_object_ref_sink (_tmp15_);
	menu_quit = _tmp16_;
	g_signal_connect ((GtkMenuItem*) menu_quit, "activate", (GCallback) _gtk_main_quit_gtk_menu_item_activate, NULL);
	_tmp17_ = self->priv->menu;
	_tmp18_ = self->priv->how_many;
	gtk_container_add ((GtkContainer*) _tmp17_, (GtkWidget*) _tmp18_);
	_tmp19_ = self->priv->menu;
	_tmp20_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
	_tmp21_ = g_object_ref_sink (_tmp20_);
	gtk_container_add ((GtkContainer*) _tmp19_, (GtkWidget*) _tmp21_);
	_g_object_unref0 (_tmp21_);
	_tmp22_ = self->priv->menu;
	_tmp23_ = self->priv->menu_execute;
	gtk_container_add ((GtkContainer*) _tmp22_, (GtkWidget*) _tmp23_);
	_tmp24_ = self->priv->menu;
	gtk_container_add ((GtkContainer*) _tmp24_, (GtkWidget*) menu_refresh);
	_tmp25_ = self->priv->menu;
	gtk_container_add ((GtkContainer*) _tmp25_, (GtkWidget*) menu_preferences);
	_tmp26_ = self->priv->menu;
	_tmp27_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
	_tmp28_ = g_object_ref_sink (_tmp27_);
	gtk_container_add ((GtkContainer*) _tmp26_, (GtkWidget*) _tmp28_);
	_g_object_unref0 (_tmp28_);
	_tmp29_ = self->priv->menu;
	gtk_container_add ((GtkContainer*) _tmp29_, (GtkWidget*) menu_about);
	_tmp30_ = self->priv->menu;
	gtk_container_add ((GtkContainer*) _tmp30_, (GtkWidget*) menu_quit);
	_tmp31_ = self->priv->menu;
	gtk_widget_show_all ((GtkWidget*) _tmp31_);
	_tmp32_ = self->priv->indicator;
	_tmp33_ = self->priv->menu;
	app_indicator_set_menu (_tmp32_, _tmp33_);
	_g_object_unref0 (menu_quit);
	_g_object_unref0 (menu_about);
	_g_object_unref0 (menu_preferences);
	_g_object_unref0 (menu_refresh);
}


static void indicate_on_update (Indicate* self, UpdateChecker* sender, gchar** packages, int packages_length1, gint count) {
	GtkMenuItem* _tmp0_;
	GtkWidget* _tmp1_ = NULL;
	gint _tmp5_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (sender != NULL);
	_tmp0_ = self->priv->how_many;
	_tmp1_ = gtk_menu_item_get_submenu (_tmp0_);
	if (_tmp1_ != NULL) {
		GtkMenuItem* _tmp2_;
		GtkMenu* _tmp3_;
		GtkMenu* _tmp4_;
		_tmp2_ = self->priv->how_many;
		_tmp3_ = (GtkMenu*) gtk_menu_new ();
		_tmp4_ = g_object_ref_sink (_tmp3_);
		gtk_menu_item_set_submenu (_tmp2_, _tmp4_);
		_g_object_unref0 (_tmp4_);
	}
	_tmp5_ = count;
	if (_tmp5_ > 0) {
		gint _tmp6_;
		AppIndicator* _tmp7_;
		const gchar* _tmp8_ = NULL;
		gint _tmp9_;
		GtkMenuItem* _tmp10_;
		gint _tmp11_;
		gchar* _tmp12_ = NULL;
		gchar* _tmp13_;
		const gchar* _tmp14_;
		gchar* _tmp15_;
		gchar* _tmp16_;
		GtkMenuItem* _tmp17_;
		GtkMenuItem* _tmp18_;
		GtkMenu* _tmp19_;
		GtkMenu* _tmp20_;
		GtkMenu* submenu_how_many;
		gchar** _tmp21_;
		gint _tmp21__length1;
		GtkMenuItem* _tmp27_;
		GtkMenu* _tmp28_;
		GtkMenu* _tmp29_;
		gboolean _tmp30_ = FALSE;
		_tmp6_ = count;
		indicate_set_active_icon (self, _tmp6_);
		_tmp7_ = self->priv->indicator;
		app_indicator_set_status (_tmp7_, APP_INDICATOR_STATUS_ACTIVE);
		_tmp9_ = count;
		if (_tmp9_ == 1) {
			_tmp8_ = " update";
		} else {
			_tmp8_ = " updates";
		}
		_tmp10_ = self->priv->how_many;
		_tmp11_ = count;
		_tmp12_ = g_strdup_printf ("%i", _tmp11_);
		_tmp13_ = _tmp12_;
		_tmp14_ = _tmp8_;
		_tmp15_ = g_strconcat (_tmp13_, _tmp14_, NULL);
		_tmp16_ = _tmp15_;
		gtk_menu_item_set_label (_tmp10_, _tmp16_);
		_g_free0 (_tmp16_);
		_g_free0 (_tmp13_);
		_tmp17_ = self->priv->how_many;
		gtk_widget_set_sensitive ((GtkWidget*) _tmp17_, TRUE);
		_tmp18_ = self->priv->menu_execute;
		gtk_widget_set_sensitive ((GtkWidget*) _tmp18_, TRUE);
		_tmp19_ = (GtkMenu*) gtk_menu_new ();
		_tmp20_ = g_object_ref_sink (_tmp19_);
		submenu_how_many = _tmp20_;
		_tmp21_ = packages;
		_tmp21__length1 = packages_length1;
		{
			gchar** package_collection = NULL;
			gint package_collection_length1 = 0;
			gint _package_collection_size_ = 0;
			gint package_it = 0;
			package_collection = _tmp21_;
			package_collection_length1 = _tmp21__length1;
			for (package_it = 0; package_it < _tmp21__length1; package_it = package_it + 1) {
				gchar* _tmp22_;
				gchar* package = NULL;
				_tmp22_ = g_strdup (package_collection[package_it]);
				package = _tmp22_;
				{
					GtkMenu* _tmp23_;
					const gchar* _tmp24_;
					GtkMenuItem* _tmp25_;
					GtkMenuItem* _tmp26_;
					_tmp23_ = submenu_how_many;
					_tmp24_ = package;
					_tmp25_ = (GtkMenuItem*) gtk_menu_item_new_with_label (_tmp24_);
					_tmp26_ = g_object_ref_sink (_tmp25_);
					gtk_container_add ((GtkContainer*) _tmp23_, (GtkWidget*) _tmp26_);
					_g_object_unref0 (_tmp26_);
					_g_free0 (package);
				}
			}
		}
		_tmp27_ = self->priv->how_many;
		_tmp28_ = submenu_how_many;
		gtk_menu_item_set_submenu (_tmp27_, _tmp28_);
		_tmp29_ = submenu_how_many;
		gtk_widget_show_all ((GtkWidget*) _tmp29_);
		_tmp30_ = gconf_interface_get_bool (GCONF_INTERFACE_KEY_NOTIFY);
		if (_tmp30_) {
			gchar* _tmp31_;
			gchar* package_list;
			gchar** _tmp32_;
			gint _tmp32__length1;
			const gchar* _tmp47_ = NULL;
			gint _tmp48_;
			gint _tmp49_;
			gchar* _tmp50_ = NULL;
			gchar* _tmp51_;
			gchar* _tmp52_;
			gchar* _tmp53_;
			const gchar* _tmp54_;
			gchar* _tmp55_;
			gchar* _tmp56_;
			gchar* _tmp57_;
			gchar* _tmp58_;
			const gchar* _tmp59_;
			NotifyNotification* _tmp60_;
			NotifyNotification* _tmp61_;
			NotifyNotification* notify;
			_tmp31_ = g_strdup ("");
			package_list = _tmp31_;
			_tmp32_ = packages;
			_tmp32__length1 = packages_length1;
			{
				gchar** package_collection = NULL;
				gint package_collection_length1 = 0;
				gint _package_collection_size_ = 0;
				gint package_it = 0;
				package_collection = _tmp32_;
				package_collection_length1 = _tmp32__length1;
				for (package_it = 0; package_it < _tmp32__length1; package_it = package_it + 1) {
					gchar* _tmp33_;
					gchar* package = NULL;
					_tmp33_ = g_strdup (package_collection[package_it]);
					package = _tmp33_;
					{
						const gchar* _tmp34_ = NULL;
						const gchar* _tmp35_;
						gchar** _tmp36_;
						gint _tmp36__length1;
						gint _tmp37_;
						const gchar* _tmp38_;
						const gchar* _tmp39_;
						const gchar* _tmp40_;
						gchar* _tmp41_;
						gchar* _tmp42_;
						const gchar* _tmp43_;
						gchar* _tmp44_;
						gchar* _tmp45_;
						gchar* _tmp46_;
						_tmp35_ = package;
						_tmp36_ = packages;
						_tmp36__length1 = packages_length1;
						_tmp37_ = count;
						_tmp38_ = _tmp36_[_tmp37_ - 1];
						if (g_strcmp0 (_tmp35_, _tmp38_) == 0) {
							_tmp34_ = "";
						} else {
							_tmp34_ = "\n";
						}
						_tmp39_ = package_list;
						_tmp40_ = package;
						_tmp41_ = g_strconcat ("- ", _tmp40_, NULL);
						_tmp42_ = _tmp41_;
						_tmp43_ = _tmp34_;
						_tmp44_ = g_strconcat (_tmp42_, _tmp43_, NULL);
						_tmp45_ = _tmp44_;
						_tmp46_ = g_strconcat (_tmp39_, _tmp45_, NULL);
						_g_free0 (package_list);
						package_list = _tmp46_;
						_g_free0 (_tmp45_);
						_g_free0 (_tmp42_);
						_g_free0 (package);
					}
				}
			}
			_tmp48_ = count;
			if (_tmp48_ == 1) {
				_tmp47_ = "update";
			} else {
				_tmp47_ = "updates";
			}
			_tmp49_ = count;
			_tmp50_ = g_strdup_printf ("%i", _tmp49_);
			_tmp51_ = _tmp50_;
			_tmp52_ = g_strconcat (_tmp51_, " new ", NULL);
			_tmp53_ = _tmp52_;
			_tmp54_ = _tmp47_;
			_tmp55_ = g_strconcat (_tmp53_, _tmp54_, NULL);
			_tmp56_ = _tmp55_;
			_tmp57_ = g_strconcat (_tmp56_, " available", NULL);
			_tmp58_ = _tmp57_;
			_tmp59_ = package_list;
			_tmp60_ = notify_notification_new (_tmp58_, _tmp59_, INDICATE_ACTIVE_ICON);
			_tmp61_ = _tmp60_;
			_g_free0 (_tmp58_);
			_g_free0 (_tmp56_);
			_g_free0 (_tmp53_);
			_g_free0 (_tmp51_);
			notify = _tmp61_;
			{
				NotifyNotification* _tmp62_;
				_tmp62_ = notify;
				notify_notification_show (_tmp62_, &_inner_error_);
				if (_inner_error_ != NULL) {
					goto __catch1_g_error;
				}
			}
			goto __finally1;
			__catch1_g_error:
			{
				GError* e = NULL;
				FILE* _tmp63_;
				GError* _tmp64_;
				const gchar* _tmp65_;
				e = _inner_error_;
				_inner_error_ = NULL;
				_tmp63_ = stderr;
				_tmp64_ = e;
				_tmp65_ = _tmp64_->message;
				fprintf (_tmp63_, "Could not show notification: %s\n", _tmp65_);
				_g_error_free0 (e);
			}
			__finally1:
			if (_inner_error_ != NULL) {
				_g_object_unref0 (notify);
				_g_free0 (package_list);
				_g_object_unref0 (submenu_how_many);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
			_g_object_unref0 (notify);
			_g_free0 (package_list);
		}
		_g_object_unref0 (submenu_how_many);
	} else {
		AppIndicator* _tmp66_;
		AppIndicatorStatus _tmp67_ = 0;
		gboolean _tmp68_ = FALSE;
		AppIndicator* _tmp69_;
		AppIndicatorStatus _tmp70_;
		GtkMenuItem* _tmp71_;
		GtkMenuItem* _tmp72_;
		GtkMenuItem* _tmp73_;
		gboolean _tmp74_ = FALSE;
		_tmp66_ = self->priv->indicator;
		app_indicator_set_icon (_tmp66_, INDICATE_PASSIVE_ICON);
		_tmp68_ = gconf_interface_get_bool (GCONF_INTERFACE_KEY_SHOW_PASSIVE_ICON);
		if (_tmp68_) {
			_tmp67_ = APP_INDICATOR_STATUS_ACTIVE;
		} else {
			_tmp67_ = APP_INDICATOR_STATUS_PASSIVE;
		}
		_tmp69_ = self->priv->indicator;
		_tmp70_ = _tmp67_;
		app_indicator_set_status (_tmp69_, _tmp70_);
		_tmp71_ = self->priv->how_many;
		gtk_menu_item_set_label (_tmp71_, "No updates available");
		_tmp72_ = self->priv->how_many;
		gtk_widget_set_sensitive ((GtkWidget*) _tmp72_, FALSE);
		_tmp73_ = self->priv->menu_execute;
		gtk_widget_set_sensitive ((GtkWidget*) _tmp73_, FALSE);
		_tmp74_ = gconf_interface_get_bool (GCONF_INTERFACE_KEY_NOTIFY);
		if (_tmp74_) {
			NotifyNotification* _tmp75_;
			NotifyNotification* notify;
			_tmp75_ = notify_notification_new ("Updates installed", "Your system is now up-to-date", INDICATE_PASSIVE_ICON);
			notify = _tmp75_;
			{
				NotifyNotification* _tmp76_;
				_tmp76_ = notify;
				notify_notification_show (_tmp76_, &_inner_error_);
				if (_inner_error_ != NULL) {
					goto __catch2_g_error;
				}
			}
			goto __finally2;
			__catch2_g_error:
			{
				GError* e = NULL;
				FILE* _tmp77_;
				GError* _tmp78_;
				const gchar* _tmp79_;
				e = _inner_error_;
				_inner_error_ = NULL;
				_tmp77_ = stderr;
				_tmp78_ = e;
				_tmp79_ = _tmp78_->message;
				fprintf (_tmp77_, "Could not show notification: %s\n", _tmp79_);
				_g_error_free0 (e);
			}
			__finally2:
			if (_inner_error_ != NULL) {
				_g_object_unref0 (notify);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
			_g_object_unref0 (notify);
		}
	}
}


static void indicate_set_active_icon (Indicate* self, gint count) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = gconf_interface_get_bool (GCONF_INTERFACE_KEY_SHOW_NUMBER_OF_UPDATES);
	if (_tmp0_) {
		cairo_surface_t* _tmp1_;
		cairo_surface_t* icon;
		cairo_surface_t* _tmp2_;
		cairo_t* _tmp3_;
		cairo_t* co;
		cairo_text_extents_t ex = {0};
		cairo_t* _tmp4_;
		cairo_t* _tmp5_;
		cairo_t* _tmp6_;
		cairo_t* _tmp7_;
		gint _tmp8_;
		gchar* _tmp9_ = NULL;
		gchar* _tmp10_;
		cairo_text_extents_t _tmp11_ = {0};
		cairo_t* _tmp12_;
		cairo_text_extents_t _tmp13_;
		gdouble _tmp14_;
		cairo_text_extents_t _tmp15_;
		gdouble _tmp16_;
		cairo_t* _tmp17_;
		gint _tmp18_;
		gchar* _tmp19_ = NULL;
		gchar* _tmp20_;
		cairo_surface_t* _tmp21_;
		cairo_surface_t* _tmp22_;
		cairo_surface_t* _tmp23_;
		AppIndicator* _tmp24_;
		AppIndicator* _tmp25_;
		_tmp1_ = cairo_image_surface_create_from_png (INDICATE_ACTIVE_ICON_EMPTY);
		icon = _tmp1_;
		_tmp2_ = icon;
		_tmp3_ = cairo_create (_tmp2_);
		co = _tmp3_;
		memset (&ex, 0, sizeof (cairo_text_extents_t));
		ex.x_bearing = (gdouble) 10;
		ex.width = (gdouble) 10;
		ex.height = (gdouble) 10;
		_tmp4_ = co;
		cairo_set_source_rgb (_tmp4_, 0.2, 0.2, 0.2);
		_tmp5_ = co;
		cairo_select_font_face (_tmp5_, "Ubuntu Mono", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
		_tmp6_ = co;
		cairo_set_font_size (_tmp6_, (gdouble) 20);
		_tmp7_ = co;
		_tmp8_ = count;
		_tmp9_ = g_strdup_printf ("%i", _tmp8_);
		_tmp10_ = _tmp9_;
		cairo_text_extents (_tmp7_, _tmp10_, &_tmp11_);
		ex = _tmp11_;
		_g_free0 (_tmp10_);
		_tmp12_ = co;
		_tmp13_ = ex;
		_tmp14_ = _tmp13_.width;
		_tmp15_ = ex;
		_tmp16_ = _tmp15_.height;
		cairo_move_to (_tmp12_, (24 - 1) - (_tmp14_ / 2), (24 - 1) + (_tmp16_ / 2));
		_tmp17_ = co;
		_tmp18_ = count;
		_tmp19_ = g_strdup_printf ("%i", _tmp18_);
		_tmp20_ = _tmp19_;
		cairo_show_text (_tmp17_, _tmp20_);
		_g_free0 (_tmp20_);
		_tmp21_ = icon;
		cairo_surface_write_to_png (_tmp21_, "/tmp/update_indicator.png");
		_tmp22_ = icon;
		cairo_surface_show_page (_tmp22_);
		_tmp23_ = icon;
		cairo_surface_finish (_tmp23_);
		_tmp24_ = self->priv->indicator;
		app_indicator_set_icon (_tmp24_, INDICATE_ACTIVE_ICON_EMPTY);
		_tmp25_ = self->priv->indicator;
		app_indicator_set_icon (_tmp25_, "/tmp/update_indicator.png");
		_cairo_destroy0 (co);
		_cairo_surface_destroy0 (icon);
	} else {
		AppIndicator* _tmp26_;
		_tmp26_ = self->priv->indicator;
		app_indicator_set_icon (_tmp26_, INDICATE_ACTIVE_ICON);
	}
}


static void indicate_on_execute_clicked (Indicate* self, GtkWidget* sender) {
	gint _tmp0_ = 0;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (sender != NULL);
	_tmp0_ = gconf_interface_get_int (GCONF_INTERFACE_KEY_UPDATE_TOOL);
	switch (_tmp0_) {
		case 0:
		{
			{
				g_spawn_command_line_async ("python /usr/lib/update-notifier/backend_helper.py show_updates", &_inner_error_);
				if (_inner_error_ != NULL) {
					goto __catch3_g_error;
				}
			}
			goto __finally3;
			__catch3_g_error:
			{
				GError* e = NULL;
				FILE* _tmp1_;
				e = _inner_error_;
				_inner_error_ = NULL;
				_tmp1_ = stderr;
				fprintf (_tmp1_, "Failed to show updates\n" \
"Execution of \"python /usr/lib/update-notifier/backend_helper.py show_" \
"updates\" failed\n");
				_g_error_free0 (e);
			}
			__finally3:
			if (_inner_error_ != NULL) {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
			break;
		}
		case 1:
		{
			{
				g_spawn_command_line_async ("python /usr/lib/update-notifier/backend_helper.py install_all_updates", &_inner_error_);
				if (_inner_error_ != NULL) {
					goto __catch4_g_error;
				}
			}
			goto __finally4;
			__catch4_g_error:
			{
				GError* e = NULL;
				FILE* _tmp2_;
				e = _inner_error_;
				_inner_error_ = NULL;
				_tmp2_ = stderr;
				fprintf (_tmp2_, "Failed to install updates\n" \
"Execution of \"python /usr/lib/update-notifier/backend_helper.py insta" \
"ll_all_updates\" failed\n");
				_g_error_free0 (e);
			}
			__finally4:
			if (_inner_error_ != NULL) {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
			break;
		}
		case 2:
		{
			{
				g_spawn_command_line_async ("gksu \"apt-get upgrade -y\"", &_inner_error_);
				if (_inner_error_ != NULL) {
					goto __catch5_g_error;
				}
			}
			goto __finally5;
			__catch5_g_error:
			{
				GError* e = NULL;
				FILE* _tmp3_;
				e = _inner_error_;
				_inner_error_ = NULL;
				_tmp3_ = stderr;
				fprintf (_tmp3_, "Failed to install updates\n" \
"Execution of \"gksu \"apt-get upgrade -y\"\" failed\n");
				_g_error_free0 (e);
			}
			__finally5:
			if (_inner_error_ != NULL) {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
			break;
		}
		default:
		break;
	}
}


static void indicate_on_refresh_clicked (Indicate* self, GtkWidget* sender) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (sender != NULL);
	{
		g_spawn_command_line_async ("python /usr/lib/update-notifier/backend_helper.py check_updates", &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch6_g_error;
		}
	}
	goto __finally6;
	__catch6_g_error:
	{
		GError* e = NULL;
		FILE* _tmp0_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp0_ = stderr;
		fprintf (_tmp0_, "Failed to refresh package list\n" \
"Execution of \"python /usr/lib/update-notifier/backend_helper.py show_" \
"updates\" failed\n");
		_g_error_free0 (e);
	}
	__finally6:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void _indicate_on_preferences_update_preferences_dialog_preferences_update (PreferencesDialog* _sender, gpointer self) {
	indicate_on_preferences_update (self, _sender);
}


static void indicate_on_preferences_clicked (Indicate* self, GtkWidget* sender) {
	PreferencesDialog* _tmp0_;
	PreferencesDialog* dialog;
	g_return_if_fail (self != NULL);
	g_return_if_fail (sender != NULL);
	_tmp0_ = preferences_dialog_new ();
	dialog = _tmp0_;
	g_signal_connect (dialog, "preferences-update", (GCallback) _indicate_on_preferences_update_preferences_dialog_preferences_update, self);
	preferences_dialog_show (dialog);
	_preferences_dialog_unref0 (dialog);
}


void indicate_on_preferences_update (Indicate* self, PreferencesDialog* sender) {
	UpdateChecker* _tmp0_;
	gint _tmp1_ = 0;
	UpdateChecker* _tmp2_;
	gint _tmp3_;
	gint _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (sender != NULL);
	_tmp0_ = self->priv->checker;
	_tmp1_ = gconf_interface_get_int (GCONF_INTERFACE_KEY_CHECK_INTERVAL);
	update_checker_set_update_interval (_tmp0_, _tmp1_);
	_tmp2_ = self->priv->checker;
	_tmp3_ = update_checker_get_count (_tmp2_);
	_tmp4_ = _tmp3_;
	if (_tmp4_ == 0) {
		gboolean _tmp5_ = FALSE;
		_tmp5_ = gconf_interface_get_bool (GCONF_INTERFACE_KEY_SHOW_PASSIVE_ICON);
		if (_tmp5_) {
			AppIndicator* _tmp6_;
			_tmp6_ = self->priv->indicator;
			app_indicator_set_status (_tmp6_, APP_INDICATOR_STATUS_ACTIVE);
		} else {
			AppIndicator* _tmp7_;
			_tmp7_ = self->priv->indicator;
			app_indicator_set_status (_tmp7_, APP_INDICATOR_STATUS_PASSIVE);
		}
	} else {
		UpdateChecker* _tmp8_;
		gint _tmp9_;
		gint _tmp10_;
		_tmp8_ = self->priv->checker;
		_tmp9_ = update_checker_get_count (_tmp8_);
		_tmp10_ = _tmp9_;
		indicate_set_active_icon (self, _tmp10_);
	}
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void indicate_on_about_clicked (Indicate* self, GtkWidget* sender) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (sender != NULL);
	{
		GtkBuilder* _tmp0_;
		GtkBuilder* builder;
		GObject* _tmp1_ = NULL;
		GtkDialog* _tmp2_;
		GtkDialog* dialog;
		GtkDialog* _tmp3_;
		GtkDialog* _tmp4_;
		_tmp0_ = gtk_builder_new ();
		builder = _tmp0_;
		gtk_builder_add_from_file (builder, INDICATE_GLADE_FILE, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_object_unref0 (builder);
			goto __catch7_g_error;
		}
		_tmp1_ = gtk_builder_get_object (builder, "about_dialog");
		_tmp2_ = _g_object_ref0 (GTK_IS_DIALOG (_tmp1_) ? ((GtkDialog*) _tmp1_) : NULL);
		dialog = _tmp2_;
		_tmp3_ = dialog;
		gtk_dialog_run (_tmp3_);
		_tmp4_ = dialog;
		gtk_widget_hide ((GtkWidget*) _tmp4_);
		_g_object_unref0 (dialog);
		_g_object_unref0 (builder);
	}
	goto __finally7;
	__catch7_g_error:
	{
		GError* e = NULL;
		FILE* _tmp5_;
		GError* _tmp6_;
		const gchar* _tmp7_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp5_ = stderr;
		_tmp6_ = e;
		_tmp7_ = _tmp6_->message;
		fprintf (_tmp5_, "Error: Couldn't load about dialog: %s'\n", _tmp7_);
		_g_error_free0 (e);
	}
	__finally7:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void value_indicate_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_indicate_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		indicate_unref (value->data[0].v_pointer);
	}
}


static void value_indicate_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = indicate_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_indicate_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_indicate_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Indicate* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = indicate_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_indicate_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Indicate** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = indicate_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_indicate (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecIndicate* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_INDICATE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_indicate (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_INDICATE), NULL);
	return value->data[0].v_pointer;
}


void value_set_indicate (GValue* value, gpointer v_object) {
	Indicate* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_INDICATE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_INDICATE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		indicate_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		indicate_unref (old);
	}
}


void value_take_indicate (GValue* value, gpointer v_object) {
	Indicate* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_INDICATE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_INDICATE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		indicate_unref (old);
	}
}


static void indicate_class_init (IndicateClass * klass) {
	indicate_parent_class = g_type_class_peek_parent (klass);
	INDICATE_CLASS (klass)->finalize = indicate_finalize;
	g_type_class_add_private (klass, sizeof (IndicatePrivate));
}


static void indicate_instance_init (Indicate * self) {
	self->priv = INDICATE_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void indicate_finalize (Indicate* obj) {
	Indicate * self;
	self = INDICATE (obj);
	_g_object_unref0 (self->priv->indicator);
	_g_object_unref0 (self->priv->menu);
	_g_object_unref0 (self->priv->how_many);
	_g_object_unref0 (self->priv->menu_execute);
	_update_checker_unref0 (self->priv->checker);
}


GType indicate_get_type (void) {
	static volatile gsize indicate_type_id__volatile = 0;
	if (g_once_init_enter (&indicate_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_indicate_init, value_indicate_free_value, value_indicate_copy_value, value_indicate_peek_pointer, "p", value_indicate_collect_value, "p", value_indicate_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (IndicateClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) indicate_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Indicate), 0, (GInstanceInitFunc) indicate_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType indicate_type_id;
		indicate_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Indicate", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&indicate_type_id__volatile, indicate_type_id);
	}
	return indicate_type_id__volatile;
}


gpointer indicate_ref (gpointer instance) {
	Indicate* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void indicate_unref (gpointer instance) {
	Indicate* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		INDICATE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



